{"title":"关于runtime","date":"2019-03-28T09:59:44.000Z","slug":"关于runtime","updated":"2019-04-02T14:48:46.925Z","content":"<h1 id=\"关于runtime\">关于runtime<a href=\"post/关于runtime#关于runtime\"></a></h1><p>1.什么是runtime？</p>\n<pre><code>1&gt; runtime是一套底层的C语言API（包含很多强大实用的C语言数据类型、C语言函数）\n2&gt; 实际上，平时我们编写的OC代码，底层都是基于runtime实现的\n</code></pre><p>也就是说，平时我们编写的OC代码，最终都是转成了底层的runtime代码（C语言代码）</p>\n<p>2.runtime有啥用？</p>\n<pre><code>1&gt; 能动态产生一个类、一个成员变量、一个方法\n2&gt; 能动态修改一个类、一个成员变量、一个方法\n3&gt; 能动态删除一个类、一个成员变量、一个方法\n</code></pre><a id=\"more\"></a>\n<p>3.常见的函数、头文件</p>\n<pre><code>#import : 成员变量、类、方法\nIvar class_copyIvarList : 获得某个类内部的所有成员变量\nMethod class_copyMethodList : 获得某个类内部的所有方法\nMethod class_getInstanceMethod : 获得某个实例方法（对象方法，减号-开头）\nMethod class_getClassMethod : 获得某个类方法（加号+开头）\nmethod_exchangeImplementations : 交换2个方法的具体实现\n</code></pre><p>4.常用方法</p>\n<p>//获取属性列表</p>\n<pre><code>objc_property_t propertyList = class_copyPropertyList([self class], &amp;count);\nfor (unsigned int i=0; i&lt;count; i++) {\n\n    const char propertyName = property_getName(propertyList[i]);\n    NSLog(@”property—-&gt;%@”, [NSString stringWithUTF8String:propertyName]);\n}\n</code></pre><p>//获取方法列表</p>\n<pre><code>Method *methodList = class_copyMethodList([self class], &amp;count);\nfor (unsigned int i; i&lt;count; i++) {\n    Method method = methodList[i];\n    NSLog(@”method—-&gt;%@”, NSStringFromSelector(method_getName(method)));\n}\n</code></pre><p>//获取成员变量列表</p>\n<pre><code>Ivar ivarList = class_copyIvarList([self class], &amp;count);\nfor (unsigned int i; i&lt;count; i++) {\n    Ivar myIvar = ivarList[i];\n    const char ivarName = ivar_getName(myIvar);\nNSLog(@”Ivar—-&gt;%@”, [NSString stringWithUTF8String:ivarName]);\n}\n</code></pre><p>//获取协议列表</p>\n<pre><code>__unsafe_unretained Protocol *protocolList = class_copyProtocolList([self class], &amp;count);\nfor (unsigned int i; i&lt;count; i++) {\n    Protocol myProtocal = protocolList[i];\n    const char *protocolName = protocol_getName(myProtocal);\n    NSLog(@”protocol—-&gt;%@”, [NSString stringWithUTF8String:protocolName]);\n}\n</code></pre><p>5.拦截调用</p>\n<p>在方法调用中说到了，如果没有找到方法就会转向拦截调用。<br>那么什么是拦截调用呢。<br>拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写NSObject的四个方法来处理。</p>\n<pre><code>(BOOL)resolveClassMethod:(SEL)sel;\n(BOOL)resolveInstanceMethod:(SEL)sel;\n//后两个方法需要转发到其他的类处理\n\n(id)forwardingTargetForSelector:(SEL)aSelector;\n(void)forwardInvocation:(NSInvocation *)anInvocation;\n</code></pre><p>5.1 第一个方法是当你调用一个不存在的类方法的时候，会调用这个方法，默认返回NO，你可以加上自己的处理然后返回YES。<br>5.2 第二个方法和第一个方法相似，只不过处理的是实例方法。<br>5.3 第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个有这个方法的target。<br>5.4 第四个方法是将你调用的不存在的方法打包成NSInvocation传给你。做完你自己的处理后，调用invokeWithTarget:方法让某个target触发这个方法。</p>\n","prev":{"title":"获取手机信息","slug":"获取手机信息"},"next":{"title":"Git详细分析","slug":"Git详细分析"},"link":"http://yoursite.com/post/关于runtime/","toc":[{"title":"关于runtime","id":"关于runtime","index":"1"}]}